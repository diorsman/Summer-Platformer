using UnityEditor;
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System;

/***
* MeshCreatorInspector
*	modifies the inspector to show controls for the Mesh Creator.
*	this script needs to be in the Editor folder of your project along
*	with the SimpleSurfaceEdge.cs and the Triangulator.cs script.
***/
[CustomEditor(typeof(MeshCreatorData))]
public class MeshCreatorInspector :  Editor {
	
	private MeshCreatorData mcd;
	
	/***
	* OnEnable
	* 	set the MeshCreator when component is added to the object
	***/
	private void OnEnable()
    {
		mcd = target as MeshCreatorData;
		if (mcd == null) {
			Debug.LogError("MeshCreatorInspector::OnEnable(): couldn't find a MeshCreatorData component");
		}
    }
	
	/***
	* OnInspectorGUI
	*	this does the main display of information in the inspector.
	***/
	public override void OnInspectorGUI() {
		EditorGUIUtility.LookLikeInspector();
		//EditorGUIUtility.LookLikeControls();
		
		// TODO: inspector layout should be redesigned so that it's easier to 
		//	 see the texture and material information
		if (mcd != null) {
			EditorGUILayout.LabelField("Mesh Creation Outline", "");
			mcd.outlineTexture = EditorGUILayout.ObjectField("Mesh Outline Texture", mcd.outlineTexture, typeof(Texture2D)) as Texture2D;
			mcd.uvWrapMesh = EditorGUILayout.Toggle("Use UV mapped mesh", mcd.uvWrapMesh);
			// this is for future support of poster graphics and mesh extrusion
			if (!mcd.uvWrapMesh) {
				mcd.createEdges = EditorGUILayout.Toggle("Use UV mapped edge", mcd.createEdges);
				mcd.createBacksidePlane = EditorGUILayout.Toggle("Use backside plane", mcd.createBacksidePlane);
			}
			EditorGUILayout.Space();
			EditorGUILayout.LabelField("Material Assignment", "");
			mcd.useAutoGeneratedMaterial = EditorGUILayout.Toggle("Use Generated Material", mcd.useAutoGeneratedMaterial);
			if (!mcd.useAutoGeneratedMaterial) mcd.frontMaterial = EditorGUILayout.ObjectField("Mesh Material", mcd.frontMaterial, typeof(Material)) as Material;
			
			EditorGUILayout.Space();
			EditorGUILayout.LabelField("Mesh Size", "");
			mcd.meshHeight = EditorGUILayout.FloatField("Mesh Height", mcd.meshHeight);
			mcd.meshWidth = EditorGUILayout.FloatField("Mesh Width", mcd.meshWidth);
			mcd.meshDepth = EditorGUILayout.FloatField("Mesh Depth", mcd.meshDepth);
			
			EditorGUILayout.Space();
			EditorGUILayout.LabelField("Relative Position", "");
			mcd.heightOffset = EditorGUILayout.FloatField("Height Offset", mcd.heightOffset);
			mcd.widthOffset = EditorGUILayout.FloatField("Width Offset", mcd.widthOffset);
			mcd.depthOffset = EditorGUILayout.FloatField("Depth Offset", mcd.depthOffset);
			
			EditorGUILayout.Space();
			EditorGUILayout.LabelField("Pivot Position", "");
			mcd.pivotHeightOffset = EditorGUILayout.FloatField("Pivot Height Offset", mcd.pivotHeightOffset);
			mcd.pivotWidthOffset = EditorGUILayout.FloatField("Pivot Width Offset", mcd.pivotWidthOffset);
			mcd.pivotDepthOffset = EditorGUILayout.FloatField("Pivot Depth Offset", mcd.pivotDepthOffset);
			
			EditorGUILayout.Space();
			EditorGUILayout.LabelField("Collider Generation", "");
			mcd.generateCollider = EditorGUILayout.Toggle("Generate Collider", mcd.generateCollider);
			if (mcd.generateCollider) mcd.usePrimitiveCollider = EditorGUILayout.Toggle("Use Primitive Collider", mcd.usePrimitiveCollider);
			if (mcd.generateCollider && mcd.usePrimitiveCollider) mcd.smallestBoxArea = EditorGUILayout.FloatField("Smallest Box Area", mcd.smallestBoxArea);
			EditorGUILayout.Space();
			if (mcd.generateCollider) {
				EditorGUILayout.Space();
				EditorGUILayout.LabelField("Physics Material", "");
				mcd.usePhysicMaterial = EditorGUILayout.Toggle("Use Physics Material", mcd.usePhysicMaterial);
				if (mcd.usePhysicMaterial) mcd.physicMaterial = EditorGUILayout.ObjectField("Physical Material", mcd.physicMaterial, typeof(PhysicMaterial)) as PhysicMaterial;
			}
			
			//
			// Allow user to save the generated meshes into a "Meshes" folder
			// User provides the name, and all sub meshes are saved
			//
			EditorGUILayout.Space();
			mcd.saveName = EditorGUILayout.TextField("Mesh Save Base Name", mcd.saveName);
			EditorGUILayout.Space();
			
			EditorGUILayout.Space();
			if (GUILayout.Button("Update Mesh", GUILayout.MaxWidth(100))) {
				// do some simple parameter checking here so we don't get into trouble
				if (mcd.smallestBoxArea < 2) {
					Debug.LogWarning("Mesh Creator: smallest box area should be larger than 1.");
				}
				else {
					UpdateMesh();
					//Editor.Repaint(); // error when deleting colliders
				}
			}
			
			
			/*if (GUILayout.Button("Save Meshes")) {
				if (mcd.saveName == "") {
					Debug.LogWarning("MeshCreator: no filename indicated for save");
					return;
				}
				// Handle the mesh on the main object
				MeshFilter mf = (MeshFilter) mcd.gameObject.GetComponent("MeshFilter");
				if (mf != null) {
					Mesh ms = mf.sharedMesh;
					if (ms != null) {
						string meshName = "Assets/Meshes/" + mcd.saveName + ".mesh";
						AssetDatabase.DeleteAsset(meshName);
						AssetDatabase.CreateAsset(ms, meshName);
					}
				}
				// Handle mesh for a backside plane if necessary
				foreach (Transform child in mcd.gameObject.transform) {
					if (child.name == (mcd.gameObject.name + ".backside") ) {
						MeshFilter bmf = (MeshFilter) child.gameObject.GetComponent("MeshFilter");
						if (bmf != null) {
							Mesh bms = bmf.sharedMesh;
							if (bms != null) {
								AssetDatabase.DeleteAsset("Assets/Meshes/" + mcd.saveName + "Backside");
								AssetDatabase.CreateAsset(bms, "Assets/Meshes/" + mcd.saveName + "Backside");
							}
						}
					}
				}
				// Handle mesh for edge plane if necessary
				foreach (Transform child in mcd.gameObject.transform) {
					if (child.name == (mcd.gameObject.name + ".edge") ) {
						MeshFilter emf = (MeshFilter) child.gameObject.GetComponent("MeshFilter");
						if (emf != null) {
							Mesh ems = emf.sharedMesh;
							if (ems != null) {
								AssetDatabase.DeleteAsset("Assets/Meshes/" + mcd.saveName + "Edge");
								AssetDatabase.CreateAsset(ems, "Assets/Meshes/" + mcd.saveName + "Edge");
							}
						}
					}
				}
			}*/
		}
		else {
			Debug.LogError("MeshCreatorInspector::OnInspectorGUI(): couldn't find a MeshCreatorData component");
		}
		
	}
	
	// this corresponds with the Update Mesh button
    void UpdateMesh () {
		// unity should prevent this from happening to the inspector, but just in case.....
		if (mcd == null) {
			Debug.LogError("MeshCreatorInspector Error: selected object does not have a MeshCreatorData component. Select an object with a MeshCreatorData component to update."); // TODO: add instructions on how to fix
			return;
		}
			
		// add a TextureImporter object here to check whether texture is readable
		// set it to readable if necessary
		if (mcd.outlineTexture == null) {
			Debug.LogError("MeshCreatorInspector Error: no texture found. Make sure to have a texture selected before updating mesh.");
			return;
		}
		
		if (mcd.saveName == "") {
			Debug.LogError("MeshCreator: no filename indicated for save. Please add a save name in the inspector and try again.");
			return;
		}
			
		// stash the rotation value, set back to identity, then switch back later
		Quaternion oldRotation = mcd.gameObject.transform.rotation;
		mcd.gameObject.transform.rotation = Quaternion.identity;
				
		// stash the scale value, set back to one, then switch back later
		Vector3 oldScale = mcd.gameObject.transform.localScale;
		mcd.gameObject.transform.localScale = Vector3.one;
		
		// transform the object if needed to account for the new pivot
		if (mcd.pivotHeightOffset != mcd.lastPivotOffset.x || mcd.pivotWidthOffset != mcd.lastPivotOffset.y || mcd.pivotWidthOffset != mcd.lastPivotOffset.z ) {
			mcd.gameObject.transform.localPosition -= mcd.lastPivotOffset;
			mcd.lastPivotOffset = new Vector3(mcd.pivotWidthOffset, mcd.pivotHeightOffset, mcd.pivotDepthOffset);
			mcd.gameObject.transform.localPosition += mcd.lastPivotOffset;
		}
		
		Mesh msh = new Mesh();
		Mesh collidermesh = new Mesh();
		if (mcd.uvWrapMesh) {
			// Set up game object with mesh;
			AssignMesh(ref msh);
			collidermesh = msh;
		}
		else {
			AssignPlaneMesh(ref msh);
			AssignMesh(ref collidermesh);
		}
			
		MeshRenderer mr = (MeshRenderer) mcd.gameObject.GetComponent("MeshRenderer");
		if (mr == null) {
			Debug.Log("MeshCreator Warning: no mesh renderer found on update object, adding one.");
			mcd.gameObject.AddComponent(typeof(MeshRenderer));
		}
			
		// update the front material via renderer
		// TODO: cleanup the redundant code below
		Material meshmat;
		if (mcd.useAutoGeneratedMaterial) {
			// if using uvWrapMesh, use regular material
			if (mcd.uvWrapMesh) {
				meshmat = (Material) Resources.LoadAssetAtPath("Assets/Materials/"+mcd.outlineTexture.name+".material.mat", typeof(Material));
				if (meshmat == null) {
					AssetDatabase.CopyAsset("Assets/Materials/baseMaterial.mat", "Assets/Materials/"+mcd.outlineTexture.name+".material.mat");
					AssetDatabase.ImportAsset("Assets/Materials/"+mcd.outlineTexture.name+".material.mat");
					meshmat = (Material) Resources.LoadAssetAtPath("Assets/Materials/"+mcd.outlineTexture.name+".material.mat", typeof(Material));
					meshmat.name = mcd.outlineTexture.name + ".Material";
					meshmat.mainTexture = mcd.outlineTexture;
					AssetDatabase.SaveAssets();
				}
				else 
				{
					Debug.LogWarning("Mesh Creator: found existing material. If you want a new one created, delete Assets/Materials/" + mcd.outlineTexture.name +".material.mat");
				}
				mcd.gameObject.renderer.sharedMaterial = meshmat;
			}
			else { // use a transparent material
				meshmat = (Material) Resources.LoadAssetAtPath("Assets/Materials/"+mcd.outlineTexture.name+".material.mat", typeof(Material));
				if (meshmat == null) {
					AssetDatabase.CopyAsset("Assets/Materials/baseTransparentMaterial.mat", "Assets/Materials/"+mcd.outlineTexture.name+".material.mat");
					AssetDatabase.ImportAsset("Assets/Materials/"+mcd.outlineTexture.name+".material.mat");
					meshmat = (Material) Resources.LoadAssetAtPath("Assets/Materials/"+mcd.outlineTexture.name+".material.mat", typeof(Material));
					meshmat.name = mcd.outlineTexture.name + ".Material";
					meshmat.mainTexture = mcd.outlineTexture;
					AssetDatabase.SaveAssets();
				}
				else {
					Debug.LogWarning("Mesh Creator: found existing material. If you want a new one created, delete Assets/Materials/" + mcd.outlineTexture.name +".material.mat");
				}
				mcd.gameObject.renderer.sharedMaterial = meshmat;
			}
		}
		else {
			mcd.gameObject.renderer.sharedMaterial = mcd.frontMaterial;
		}
			
		MeshFilter mf = (MeshFilter) mcd.gameObject.GetComponent("MeshFilter");
		if (mf == null) {
			Debug.LogWarning("MeshCreator Warning: no mesh filter found on update object, adding one.");
			mf= mcd.gameObject.AddComponent(typeof(MeshFilter)) as MeshFilter;
		}
		DestroyImmediate(mf.sharedMesh, true);  // get rid of the old shared mesh
		mf.sharedMesh = msh;
		string meshName = "Assets/Meshes/" + mcd.saveName + ".mesh";
		AssetDatabase.CreateAsset(msh, meshName);

			
		// if we need the side edges, go ahead and make a new game object for that
		if (!mcd.uvWrapMesh && mcd.createEdges) {
			Mesh edgemesh = new Mesh();
			AssignEdgeMesh(ref edgemesh);
				
			// remove the old backside mesh game object
			string edgeName = mcd.gameObject.name + ".edge";
			ArrayList destroyObject = new ArrayList();
			foreach (Transform child in mcd.gameObject.transform) {
				if (child.name == edgeName) {
					MeshFilter emf = (MeshFilter) child.gameObject.GetComponent("MeshFilter");
					if (emf != null) {
						Mesh ems = (Mesh) emf.sharedMesh;
						if (ems != null) {
							DestroyImmediate(ems, true);
						}
					}
					destroyObject.Add(child);
				}
			}
				
			while (destroyObject.Count > 0) {
				Transform child = (Transform) destroyObject[0];
				destroyObject.Remove(child);
				DestroyImmediate(child.gameObject);
			}
				
			// create a new game object to attach the backside plane
			GameObject edgeObject = new GameObject();
			edgeObject.transform.parent = mcd.gameObject.transform;
			edgeObject.transform.localPosition = Vector3.zero;
			edgeObject.transform.rotation = Quaternion.identity;
			edgeObject.name = edgeName;
			MeshFilter edgemf = (MeshFilter) edgeObject.AddComponent(typeof(MeshFilter)) as MeshFilter;
			edgemf.sharedMesh = edgemesh;
			// save the mesh in the Assets folder
			string edgeMeshName = "Assets/Meshes/" + mcd.saveName + "Edge" + ".mesh";
			AssetDatabase.CreateAsset(edgemesh, edgeMeshName);
				
			MeshRenderer edgemr = edgeObject.AddComponent(typeof(MeshRenderer)) as MeshRenderer;
			edgemr.renderer.sharedMaterial = mcd.gameObject.renderer.sharedMaterial;
		}
		else {
			string edgeName = mcd.gameObject.name + ".edge";
			ArrayList destroyObject = new ArrayList();
			foreach (Transform child in mcd.gameObject.transform) {
				if (child.name == edgeName) {
					destroyObject.Add(child);
					MeshFilter emf = (MeshFilter) child.gameObject.GetComponent("MeshFilter");
					if (emf != null) {
						Mesh ems = (Mesh) emf.sharedMesh;
						if (ems != null) {
							DestroyImmediate(ems, true);
						}
					}
				}
			}
			while (destroyObject.Count > 0) {
				Transform child = (Transform) destroyObject[0];
				destroyObject.Remove(child);
				DestroyImmediate(child.gameObject);
			}
		}
			
		if (!mcd.uvWrapMesh && mcd.createBacksidePlane) {
			Mesh backmesh = new Mesh();
			AssignPlaneMeshBackside(ref backmesh);
				
			// remove the old backside mesh game object
			string backsideName = mcd.gameObject.name + ".backside";
			ArrayList destroyObject = new ArrayList();
			foreach (Transform child in mcd.gameObject.transform) {
				if (child.name == backsideName) {
					destroyObject.Add(child);
					MeshFilter emf = (MeshFilter) child.gameObject.GetComponent("MeshFilter");
					if (emf != null) {
						Mesh ems = (Mesh) emf.sharedMesh;
						if (ems != null) {
							DestroyImmediate(ems, true);
						}
					}
				}
			}
			
			while (destroyObject.Count > 0) {
				Transform child = (Transform) destroyObject[0];
				destroyObject.Remove(child);
				DestroyImmediate(child.gameObject);
			}
				
			// create a new game object to attach the backside plane
			GameObject backsideObject = new GameObject();
			backsideObject.transform.parent = mcd.gameObject.transform;
			backsideObject.transform.localPosition = Vector3.zero;
			backsideObject.transform.rotation = Quaternion.identity;
			backsideObject.name = backsideName;
			MeshFilter backmf = (MeshFilter) backsideObject.AddComponent(typeof(MeshFilter)) as MeshFilter;
			backmf.sharedMesh = backmesh;
			// save the mesh in the Assets folder
			string backMeshName = "Assets/Meshes/" + mcd.saveName + "Back" + ".mesh";
			AssetDatabase.CreateAsset(backmesh, backMeshName);
				
			MeshRenderer backmr = backsideObject.AddComponent(typeof(MeshRenderer)) as MeshRenderer;
			backmr.renderer.sharedMaterial = mcd.gameObject.renderer.sharedMaterial;
		}
		else {
			// remove the old backside mesh game object
			string backsideName = mcd.gameObject.name + ".backside";
			ArrayList destroyObject = new ArrayList();
			foreach (Transform child in mcd.gameObject.transform) {
				if (child.name == backsideName) {
					destroyObject.Add(child);
					// get rid of the old mesh from the assets
					MeshFilter emf = (MeshFilter) child.gameObject.GetComponent("MeshFilter");
					if (emf != null) {
						Mesh ems = (Mesh) emf.sharedMesh;
						if (ems != null) {
							DestroyImmediate(ems, true);
						}
					}
				}
			}
				
			while (destroyObject.Count > 0) {
				Transform child = (Transform) destroyObject[0];
				destroyObject.Remove(child);
				DestroyImmediate(child.gameObject);
			}
		}
			
		// generate a mesh collider
		if (mcd.generateCollider && !mcd.usePrimitiveCollider) {
			Collider col = mcd.gameObject.collider;
			if (col == null) {
				mcd.gameObject.AddComponent(typeof(MeshCollider));
			}
			// remove the old compound collider if necessary
			string compoundColliderName = mcd.gameObject.name + "CompoundColliders";
			foreach(Transform child in mcd.gameObject.transform) {
				if (child.name == compoundColliderName) {
					DestroyImmediate(child.gameObject);
				}
			}
				
			MeshCollider mcol = mcd.gameObject.GetComponent("MeshCollider") as MeshCollider;
			if (mcol == null) {
				Debug.LogWarning("MeshCreator Warning: found a non-Mesh collider on object to update. If you really want a new collider generated, remove the old one and update the object with MeshCreator again.");
			}
			else {
				mcol.sharedMesh = collidermesh;
			}
			if (mcd.usePhysicMaterial) {
				mcol.material = mcd.physicMaterial;
			}
		}
		else if (mcd.generateCollider && mcd.usePrimitiveCollider) {
			// remove the old collider if necessary
			Collider col = mcd.gameObject.collider;
			if (col != null) { 
				Debug.LogWarning("Mesh Creator: found a collider on game object " + name +", please remove it.");
				MeshCollider mshcol = mcd.gameObject.GetComponent("MeshCollider") as MeshCollider;
				if (mshcol != null) {
					Debug.LogWarning("Mesh Creator: found a mesh collider on game object " + name + ", destroying it's mesh.");
					mshcol.sharedMesh = null;
				}
			}
				
			// all compound colliders are stored in a gameObject 
			string compoundColliderName = mcd.gameObject.name + "CompoundColliders";
			GameObject go = new GameObject();
			
			// find old compound colliders and remove
			foreach (Transform child in mcd.gameObject.transform) {
				if (child.name == compoundColliderName) {
					DestroyImmediate(go);
					go = child.gameObject;
					ArrayList removeChildren = new ArrayList();
					foreach (Transform childchild in child) {
						removeChildren.Add(childchild);
					}
					foreach (Transform childchild in removeChildren) {
						DestroyImmediate(childchild.gameObject);
					}
				}
			}
				
			go.name = compoundColliderName;
			go.transform.parent = mcd.gameObject.transform;
			go.transform.localPosition = Vector3.zero;
			go.transform.rotation = Quaternion.identity;
			ArrayList boxColliderCoordinates = GetBoxColliderCoordinates();
			int count = 0;
			int imageHeight = mcd.outlineTexture.height;
			int imageWidth = mcd.outlineTexture.width;
			foreach (Vector4 bcc in boxColliderCoordinates) {
				Vector4 bc = bcc;
				
				// if using a uvWrapMesh, subtract half a pixel from each side 
				if (mcd.uvWrapMesh && Math.Abs(bc.x - bc.z) > 1.0f && Math.Abs(bc.y - bc.w) > 1.0f) {
					bc.x += 0.5f;
					bc.y += 0.5f;
					bc.z -= 0.5f;
					bc.w -= 0.5f;
				}
				else if (mcd.uvWrapMesh) { // if here, height or width is only one
					continue;
				}
				count++;
				GameObject colgo = new GameObject();
				colgo.name = compoundColliderName+"."+count;
				colgo.transform.parent = go.transform;
				colgo.transform.localPosition = Vector3.zero;
				BoxCollider bxcol = colgo.AddComponent(typeof(BoxCollider)) as BoxCollider;
					
				float vertX = 1.0f - (bc.x/imageWidth) ; // get X point and normalize
				float vertY = bc.y/imageHeight ; // get Y point and normalize
				float vert2X = 1.0f - (bc.z/imageWidth);
				float vert2Y = bc.w/imageHeight;
				vertX = (vertX * mcd.meshWidth) - (mcd.meshWidth / 2.0f);  // scale X and position centered
				vertY = (vertY * mcd.meshHeight) - (mcd.meshHeight / 2.0f);
				vertX = vertX + mcd.widthOffset;
				vertY = vertY + mcd.heightOffset;
					
				vert2X = (vert2X * mcd.meshWidth) - (mcd.meshWidth / 2.0f);  // scale X and position centered
				vert2Y = (vert2Y * mcd.meshHeight) - (mcd.meshHeight / 2.0f);
				vert2X = vert2X + mcd.widthOffset;
				vert2Y = vert2Y + mcd.heightOffset;
					
				bxcol.center = new Vector3(vertX - ((vertX-vert2X)/2.0f)-mcd.pivotWidthOffset, vertY - ((vertY-vert2Y)/2.0f)-mcd.pivotHeightOffset, mcd.depthOffset - mcd.pivotDepthOffset);
				bxcol.size = new Vector3(Math.Abs(vertX-vert2X), Math.Abs(vertY-vert2Y), mcd.meshDepth);
				if (mcd.usePhysicMaterial) {
					bxcol.material = mcd.physicMaterial;
				}
			}
		}
			
		/*Mesh createdMesh = mf.sharedMesh;
		Vector3[] createdVerts = createdMesh.vertices;
		foreach(Vector3 vert in createdVerts) {
			Debug.Log(vert);
		}
		Debug.Log(createdMesh.bounds);*/
			
		mcd.gameObject.transform.rotation = oldRotation;
		mcd.gameObject.transform.localScale = oldScale;
    }  
	
	// TODO: this should be moved to another script, kinda funky here
	ArrayList GetBoxColliderCoordinates() {
		ArrayList boxCoordinates = new ArrayList();
		string path = AssetDatabase.GetAssetPath(mcd.outlineTexture);
		TextureImporter textureImporter = AssetImporter.GetAtPath(path) as TextureImporter;
		textureImporter.isReadable = true;
		AssetDatabase.ImportAsset(path);

		Color[] pixels = mcd.outlineTexture.GetPixels();	// get the pixels to build the mesh from
			
		// possibly do some size checking
		// TODO: check for a square power of two
		int imageHeight = mcd.outlineTexture.height;
		int imageWidth = mcd.outlineTexture.width;
		
		if ( ((float)imageWidth)/((float)imageHeight) != mcd.meshWidth/mcd.meshHeight) {
			Debug.LogWarning("Mesh Creator Inspector Warning: selected meshWidth and meshHeight is not the same proportion as source image width and height. Results may be distorted.");
		}
		
		// copy the pixels so they can be modified
		Color[] pix = new Color[pixels.Length];
		for (int i = 0; i < pixels.Length; i++) {
			Color pixel = pixels[i];
			pix[i] = new Color(pixel.r, pixel.g, pixel.b, pixel.a);
		}
		
		Vector4 boxCoord = GetLargestBox(ref pix, imageWidth, imageHeight);
		while ((Math.Abs(boxCoord.x-boxCoord.z) * Math.Abs(boxCoord.y-boxCoord.w) ) >= mcd.smallestBoxArea) {
			//Debug.Log("Largest Box " + boxCoord);
			boxCoordinates.Add(boxCoord);
			boxCoord = GetLargestBox(ref pix, imageWidth, imageHeight);
		}
		//Debug.Log("Last box was " + boxCoord);
		return boxCoordinates;
	}
	
	

// based on algorithm from http://e-maxx.ru/algo/maximum_zero_submatrix
Vector4 GetLargestBox(ref Color[] pixs, int imageWidth, int imageHeight) {
	Vector4 largestBox = new Vector4(-1.0f,-1.0f,-1.0f,-1.0f);
	int n = imageHeight;
	int m = imageWidth; 
	//List<int> olist = new List<int>(m);
	List< List<int> > a = new List< List<int> > ( n ) ;
	for (int i = 0; i < n; i++) {
		a.Add(new List<int>(m));
		for (int j = 0; j < m; j++) {
			a[i].Add(0);
		}
	}
	//Debug.Log("a has " + a.Count);
	for  ( int I = 0 ; I < n ; I++ ) {
		for  ( int j = 0 ; j < m ;  j++ ) {
			if (pixs[j + (imageWidth * I )].a != 1.0f) a[ I ][ j ] = 1; // is this right?
			//else a[ I ][ j ] = 0;
		}
	}
	 
	int ans =  0 ;
	List < int > d  = new List < int > ( m );
	List < int > d1 = new List <int> ( m );
	List <int >  d2 = new List<int>( m ) ;
	for (int i = 0; i < m; ++i) {
		d.Add(-1);
		d1.Add(-1);
		d2.Add(-1);
	}
	
	Stack < int > st = new Stack<int>(); 
	for (int i=0; i<n; ++i) {
		for (int j=0; j<m; ++j) if (a[i][j] == 1) d[j] = i;
		while (st.Count > 0) st.Pop(); // empty the stack
		for (int j=0; j<m; ++j) {
			while (st.Count > 0 && d[st.Peek()] <= d[j])  st.Pop();
			d1[j] = st.Count == 0 ? -1 : st.Peek();
			st.Push(j);
		}
		while (st.Count > 0) st.Pop();
		for (int j=m-1; j>=0; --j) {
			while (st.Count>0 && d[st.Peek()] <= d[j])  st.Pop();
			d2[j] = st.Count == 0 ? m : st.Peek();
			st.Push (j);
		}
		for (int j=0; j<m; ++j) {
			int oldLarge = ans;
			ans = Math.Max (ans, (i - d[j]) * (d2[j] - d1[j] - 1));
			if (oldLarge != ans) {
				largestBox[2] = d2[j];//correct
				largestBox[3] = i+1; // correct
				largestBox[0] = d1[j] +1;//(d2[j] - d1[j] - 1);
				largestBox[1] = d[j]+1;
			}
		}
	} 
	
	// remove inside pixels from the box area
		if (largestBox.x != -1.0f) {
			for (int i = (int)largestBox.x ; i < (int)largestBox.z; i++) {
				for (int j = (int)largestBox.y ; j < (int)largestBox.w; j++) {
					pixs[i + (j *imageWidth)].a = 0.0f;
				}
			}
			// delete all pixels if this is width 1 or height 1
			if ( ((int)Math.Abs(largestBox.x-largestBox.z) == 1) || ((int)Math.Abs(largestBox.y-largestBox.w) == 1) ){
				for (int i = (int)largestBox.x; i <= (int)largestBox.z; i++) {
					for (int j = (int)largestBox.y; j <= (int)largestBox.w; j++) {
						pixs[i + (j *imageWidth)].a = 0.0f;
					}
				}
			}
		}
		else {
			Debug.Log("got negative box");
		}
	
	return largestBox;
}
	
	
	/*
	*	AssignMesh() does calculation of a uv mapped mesh from the raster image.
	*/ 
	public void AssignMesh(ref Mesh msh) {
			string path = AssetDatabase.GetAssetPath(mcd.outlineTexture);
			TextureImporter textureImporter = AssetImporter.GetAtPath(path) as TextureImporter;
			textureImporter.isReadable = true;
			AssetDatabase.ImportAsset(path);
			
			//Debug.Log("found texture " + outlineTexture.width + "," + outlineTexture.height);
			Color[] pixels = mcd.outlineTexture.GetPixels();	// get the pixels to build the mesh from
			//Debug.Log("total pixel count " + pixels.Length);
			
			// possibly do some size checking
			int imageHeight = mcd.outlineTexture.height;
			int imageWidth = mcd.outlineTexture.width;
			if ( ((float)imageWidth)/((float)imageHeight) != mcd.meshWidth/mcd.meshHeight) {
				Debug.LogWarning("Mesh Creator Inspector Warning: selected meshWidth and meshHeight is not the same proportion as source image width and height. Results may be distorted.");
				Debug.LogWarning("    You may want to resize your image to be square, it can be easier that way.");
			}
			
			// make a surface object to create and store data from image
			MC_SimpleSurfaceEdge mcs = new MC_SimpleSurfaceEdge(pixels,  imageWidth, imageHeight);
			
			// Create the mesh
			//Mesh msh = new Mesh();
			
			if (!mcs.ContainsIslands()) {
				// need a list of ordered 2d points
				Vector2 [] vertices2D = mcs.GetOutsideEdgeVertices();
        
				// Use the triangulator to get indices for creating triangles
				Triangulator tr = new Triangulator(vertices2D);
				int[] indices = tr.Triangulate(); // these will be reversed for the back side
				Vector2[] uvs = new Vector2[vertices2D.Length * 4];
				// Create the Vector3 vertices
				Vector3[] vertices = new Vector3[vertices2D.Length * 4];
				//Vector3[] verticesBack = new Vector3[vertices2D.Length];
			
				float halfDepth = -mcd.meshDepth/2.0f;
				float halfVerticalPixel = 0.5f/imageHeight;
				float halfHorizontalPixel = 0.5f/imageWidth;
				for (int i=0; i<vertices2D.Length; i++) {
					float vertX = 1.0f - (vertices2D[i].x/imageWidth) - halfHorizontalPixel; // get X point and normalize
					float vertY = vertices2D[i].y/imageHeight + halfVerticalPixel; // get Y point and normalize
					vertX = (vertX * mcd.meshWidth) - (mcd.meshWidth / 2.0f);  // scale X and position centered
					vertY = (vertY * mcd.meshHeight) - (mcd.meshHeight / 2.0f);
					vertX = vertX + mcd.widthOffset;
					vertY = vertY + mcd.heightOffset;
					vertices[i] = new Vector3(vertX - mcd.pivotWidthOffset, vertY - mcd.pivotHeightOffset, -halfDepth + mcd.depthOffset - mcd.pivotDepthOffset);
					vertices[i + vertices2D.Length] = new Vector3(vertX - mcd.pivotWidthOffset, vertY - mcd.pivotHeightOffset, halfDepth + mcd.depthOffset-mcd.pivotDepthOffset);
					vertices[i+(vertices2D.Length*2)] = new Vector3(vertX - mcd.pivotWidthOffset, vertY - mcd.pivotHeightOffset, -halfDepth + mcd.depthOffset-mcd.pivotDepthOffset); // vertex for side
					vertices[i +(vertices2D.Length*3)] = new Vector3(vertX-mcd.pivotWidthOffset, vertY-mcd.pivotHeightOffset, halfDepth + mcd.depthOffset-mcd.pivotDepthOffset);
					uvs[i] = mcs.GetUVForIndex(i);
					uvs[i+vertices2D.Length] = uvs[i];
					uvs[i+(vertices2D.Length*2)] = uvs[i];
					uvs[i+(vertices2D.Length*3)] = uvs[i];
				}
			
				// make the back side triangle indices
				// double the indices for front and back, 6 times the number of edges on front
				int[] allIndices = new int[(indices.Length*2) + ( (vertices2D.Length ) * 6)];
			
				// copy over the front and back index data
				for (int i = 0; i < indices.Length; i++) {
					allIndices[i] = indices[i]; // front side uses normal indices returned from the algorithm
					allIndices[(indices.Length*2) - i -1] = indices[i] + vertices2D.Length; // backside reverses the order
				}
			
				// create the side triangle indices
				// for each edge, create a new set of two triangles
				// edges are just two points from the original set
				for (int i = 0; i < vertices2D.Length - 1; i++) {
					allIndices[(indices.Length*2) + (6 * i)] = (vertices2D.Length *2) + i + 1;
					allIndices[(indices.Length*2) + (6 * i) + 1] = (vertices2D.Length *2) +i ;
					allIndices[(indices.Length*2) + (6 * i) + 2] = (vertices2D.Length *2) + i + 1 + vertices2D.Length;
					allIndices[(indices.Length*2) + (6 * i) + 3] = (vertices2D.Length *2) + i + 1 + vertices2D.Length;
					allIndices[(indices.Length*2) + (6 * i) + 4] = (vertices2D.Length *2) + i ;
					allIndices[(indices.Length*2) + (6 * i) + 5] = (vertices2D.Length *2) + i + vertices2D.Length;
				}
			
				// wrap around for the last face
				allIndices[allIndices.Length-6] = (vertices2D.Length *2) + 0;
				allIndices[allIndices.Length-5] = (vertices2D.Length *2) +vertices2D.Length-1;
				allIndices[allIndices.Length-4] = (vertices2D.Length *2) +vertices2D.Length;
				allIndices[allIndices.Length-3] = (vertices2D.Length *2) +vertices2D.Length;
				allIndices[allIndices.Length-2] = (vertices2D.Length *2) +vertices2D.Length-1;
				allIndices[allIndices.Length-1] = (vertices2D.Length *2) + (vertices2D.Length*2) - 1;
		
			
				msh.vertices = vertices;
				msh.triangles = allIndices;
				msh.uv = uvs;
				msh.RecalculateNormals();
				msh.RecalculateBounds();
				msh.name = mcd.outlineTexture.name + ".mesh";
				
				// this will get the pivot drawing in the correct place
				Bounds oldBounds = msh.bounds;
				msh.bounds = new Bounds(Vector3.zero, new Vector3(oldBounds.size.x, oldBounds.size.y, oldBounds.size.z));
			}
			else { // there be islands here, so treat mesh creation slightly differently
				ArrayList allVertexLoops = mcs.GetAllEdgeVertices();
				
				ArrayList completeVertices = new ArrayList();
				ArrayList completeIndices = new ArrayList();
				ArrayList completeUVs = new ArrayList();
				int verticesOffset = 0;
				int indicesOffset = 0;
				int uvOffset = 0;
				int loopCount = 0;
				foreach (Vector2[] vertices2D in allVertexLoops) {
					// TODO: this needs to check if the current list is inside another shape
					// Use the triangulator to get indices for creating triangles
					Triangulator tr = new Triangulator(vertices2D);
					int[] indices = tr.Triangulate(); // these will be reversed for the back side
					Vector2[] uvs = new Vector2[vertices2D.Length * 4];
					// Create the Vector3 vertices
					Vector3[] vertices = new Vector3[vertices2D.Length * 4];
			
					float halfDepth = -mcd.meshDepth/2.0f;
					float halfVerticalPixel = 0.5f/imageHeight;
					float halfHorizontalPixel = 0.5f/imageWidth;
					for (int i=0; i<vertices2D.Length; i++) {
						float vertX = 1.0f - (vertices2D[i].x/imageWidth) - halfHorizontalPixel; // get X point and normalize
						float vertY = vertices2D[i].y/imageHeight + halfVerticalPixel; // get Y point and normalize
						vertX = (vertX * mcd.meshWidth) - (mcd.meshWidth / 2.0f);  // scale X and position centered
						vertY = (vertY * mcd.meshHeight) - (mcd.meshHeight / 2.0f);
						vertX = vertX + mcd.widthOffset;
						vertY = vertY + mcd.heightOffset;
						vertices[i] = new Vector3(vertX-mcd.pivotWidthOffset, vertY-mcd.pivotHeightOffset, -halfDepth + mcd.depthOffset-mcd.pivotDepthOffset);
						vertices[i + vertices2D.Length] = new Vector3(vertX-mcd.pivotWidthOffset, vertY-mcd.pivotHeightOffset, halfDepth + mcd.depthOffset-mcd.pivotDepthOffset);
						vertices[i+(vertices2D.Length*2)] = new Vector3(vertX-mcd.pivotWidthOffset, vertY-mcd.pivotHeightOffset, -halfDepth + mcd.depthOffset-mcd.pivotDepthOffset); // vertex for side
						vertices[i +(vertices2D.Length*3)] = new Vector3(vertX-mcd.pivotWidthOffset, vertY-mcd.pivotHeightOffset, halfDepth + mcd.depthOffset-mcd.pivotDepthOffset);
						uvs[i] = mcs.GetUVForIndex(loopCount, i);
						uvs[i+vertices2D.Length] = uvs[i];
						uvs[i+(vertices2D.Length*2)] = uvs[i];
						uvs[i+(vertices2D.Length*3)] = uvs[i];
					}
			
					// make the back side triangle indices
					// double the indices for front and back, 6 times the number of edges on front
					int[] allIndices = new int[(indices.Length*2) + ( (vertices2D.Length ) * 6)];
			
					// copy over the front and back index data
					for (int i = 0; i < indices.Length; i++) {
						allIndices[i] = indices[i] +verticesOffset; // front side uses normal indices returned from the algorithm
						allIndices[(indices.Length*2) - i -1] = indices[i] + vertices2D.Length + verticesOffset; // backside reverses the order
					}
			
					// create the side triangle indices
					// for each edge, create a new set of two triangles
					// edges are just two points from the original set
					for (int i = 0; i < vertices2D.Length - 1; i++) {
						allIndices[(indices.Length*2) + (6 * i)] = (vertices2D.Length *2) + i + 1 + verticesOffset;
						allIndices[(indices.Length*2) + (6 * i) + 1] = (vertices2D.Length *2) +i + verticesOffset;
						allIndices[(indices.Length*2) + (6 * i) + 2] = (vertices2D.Length *2) + i + 1 + vertices2D.Length+ verticesOffset;
						allIndices[(indices.Length*2) + (6 * i) + 3] = (vertices2D.Length *2) + i + 1 + vertices2D.Length+ verticesOffset;
						allIndices[(indices.Length*2) + (6 * i) + 4] = (vertices2D.Length *2) + i + verticesOffset;
						allIndices[(indices.Length*2) + (6 * i) + 5] = (vertices2D.Length *2) + i + vertices2D.Length+ verticesOffset;
					}
			
					// wrap around for the last face
					allIndices[allIndices.Length-6] = (vertices2D.Length *2) + 0+ verticesOffset;
					allIndices[allIndices.Length-5] = (vertices2D.Length *2) +vertices2D.Length-1+ verticesOffset;
					allIndices[allIndices.Length-4] = (vertices2D.Length *2) +vertices2D.Length+ verticesOffset;
					allIndices[allIndices.Length-3] = (vertices2D.Length *2) +vertices2D.Length+ verticesOffset;
					allIndices[allIndices.Length-2] = (vertices2D.Length *2) +vertices2D.Length-1+ verticesOffset;
					allIndices[allIndices.Length-1] = (vertices2D.Length *2) + (vertices2D.Length*2) - 1+ verticesOffset;
					
					foreach(Vector3 v in vertices) {
						completeVertices.Add(v);
					}
					foreach(Vector2 v in uvs) {
						completeUVs.Add(v);
					}
					foreach(int i in allIndices) {
						completeIndices.Add(i);
					}
					
					verticesOffset += vertices.Length;
					uvOffset += uvs.Length;
					indicesOffset += allIndices.Length;
					loopCount++;
				}
				msh.vertices = (Vector3[]) completeVertices.ToArray(typeof(Vector3));
				msh.triangles = (int[]) completeIndices.ToArray(typeof(int));
				msh.uv = (Vector2[]) completeUVs.ToArray(typeof(Vector2));
				msh.RecalculateNormals();
				msh.RecalculateBounds();
				msh.name = mcd.outlineTexture.name + ".mesh";
				
				// this will get the pivot drawing in the correct place
				Bounds oldBounds = msh.bounds;
				msh.bounds = new Bounds(Vector3.zero, new Vector3(oldBounds.size.x, oldBounds.size.y, oldBounds.size.z));
			}
	}
	
	/*
	*	AssignFlatMesh() does calculation of a uv mapped plane from the raster image.
	*/ 
	/*public void AssignFlatMesh(ref Mesh msh) {
		// get the outline texture
		string path = AssetDatabase.GetAssetPath(mcd.outlineTexture);
		TextureImporter textureImporter = AssetImporter.GetAtPath(path) as TextureImporter;
		textureImporter.isReadable = true;
		AssetDatabase.ImportAsset(path);

		// do some size checking
		int imageHeight = mcd.outlineTexture.height;
		int imageWidth = mcd.outlineTexture.width;
		
		if ( ((float)imageWidth)/((float)imageHeight) != mcd.meshWidth/mcd.meshHeight) {
			Debug.LogWarning("Mesh Creator Inspector Warning: selected meshWidth and meshHeight is not the same proportion as source image width and height. Results may be distorted.");
			Debug.LogWarning("    You may want to resize your image to be square, it can be easier that way.");
		}
		
		// need a list of ordered 2d points
		Vector2 [] vertices2D = {new Vector2(0.0f,0.0f), new Vector2(0.0f, imageHeight), new Vector2(imageWidth, imageHeight), new Vector2(imageWidth,0.0f)};
        
		// 
		int[] indices = {0,1,2,0,2,3}; // these will be reversed for the back side
		Vector2[] frontUVs = {new Vector2(0.0f,0.0f), new Vector2(0.0f,1.0f), new Vector2(1.0f,1.0f), new Vector2(1.0f,0.0f) };
		Vector2[] uvs = new Vector2[vertices2D.Length * 4];
		// Create the Vector3 vertices
		Vector3[] vertices = new Vector3[vertices2D.Length * 4];
		
		float halfDepth = -mcd.meshDepth/2.0f;
		for (int i=0; i<vertices2D.Length; i++) {
			float vertX = 1.0f - (vertices2D[i].x/imageWidth) ; // get X point and normalize
			float vertY = vertices2D[i].y/imageHeight; // get Y point and normalize
			vertX = (vertX * mcd.meshWidth) - (mcd.meshWidth / 2.0f);  // scale X and position centered
			vertY = (vertY * mcd.meshHeight) - (mcd.meshHeight / 2.0f);
			vertX = vertX + mcd.widthOffset;
			vertY = vertY + mcd.heightOffset;
			vertices[i] = new Vector3(vertX-mcd.pivotWidthOffset, vertY - mcd.pivotHeightOffset, -halfDepth + mcd.depthOffset - mcd.pivotDepthOffset);
			vertices[i + vertices2D.Length] = new Vector3(vertX-mcd.pivotWidthOffset, vertY-mcd.pivotHeightOffset, halfDepth + mcd.depthOffset - mcd.pivotDepthOffset);
			vertices[i+(vertices2D.Length*2)] = new Vector3(vertX-mcd.pivotWidthOffset, vertY-mcd.pivotHeightOffset, -halfDepth + mcd.depthOffset - mcd.pivotDepthOffset); // vertex for side
			vertices[i +(vertices2D.Length*3)] = new Vector3(vertX-mcd.pivotWidthOffset, vertY-mcd.pivotHeightOffset, halfDepth + mcd.depthOffset - mcd.pivotDepthOffset);
			uvs[i] = frontUVs[i];
			uvs[i+vertices2D.Length] = uvs[i];
			uvs[i+(vertices2D.Length*2)] = uvs[i];
			uvs[i+(vertices2D.Length*3)] = uvs[i];
			Debug.Log(vertices[i] );
		}
			
		// make the back side triangle indices
		// double the indices for front and back, 6 times the number of edges on front
		int[] allIndices = new int[(indices.Length*2) + ( (vertices2D.Length ) * 6)];
			
		// copy over the front and back index data
		for (int i = 0; i < indices.Length; i++) {
			allIndices[i] = indices[i]; // front side uses normal indices returned from the algorithm
			allIndices[(indices.Length*2) - i -1] = indices[i] + vertices2D.Length; // backside reverses the order
		}
			
		// create the side triangle indices
		// for each edge, create a new set of two triangles
		// edges are just two points from the original set
		for (int i = 0; i < vertices2D.Length - 1; i++) {
			allIndices[(indices.Length*2) + (6 * i)] = (vertices2D.Length *2) + i + 1;
			allIndices[(indices.Length*2) + (6 * i) + 1] = (vertices2D.Length *2) +i ;
			allIndices[(indices.Length*2) + (6 * i) + 2] = (vertices2D.Length *2) + i + 1 + vertices2D.Length;
			allIndices[(indices.Length*2) + (6 * i) + 3] = (vertices2D.Length *2) + i + 1 + vertices2D.Length;
			allIndices[(indices.Length*2) + (6 * i) + 4] = (vertices2D.Length *2) + i ;
			allIndices[(indices.Length*2) + (6 * i) + 5] = (vertices2D.Length *2) + i + vertices2D.Length;
		}
			
		// wrap around for the last face
		allIndices[allIndices.Length-6] = (vertices2D.Length *2) + 0;
		allIndices[allIndices.Length-5] = (vertices2D.Length *2) +vertices2D.Length-1;
		allIndices[allIndices.Length-4] = (vertices2D.Length *2) +vertices2D.Length;
		allIndices[allIndices.Length-3] = (vertices2D.Length *2) +vertices2D.Length;
		allIndices[allIndices.Length-2] = (vertices2D.Length *2) +vertices2D.Length-1;
		allIndices[allIndices.Length-1] = (vertices2D.Length *2) + (vertices2D.Length*2) - 1;
			
		msh.vertices = vertices;
		msh.triangles = allIndices;
		msh.uv = uvs;
		msh.RecalculateNormals();
		msh.RecalculateBounds();
		msh.name = mcd.outlineTexture.name + ".mesh";
	}*/
	
	/*
	*	AssignPlaneMesh() does calculation for a simple plane with uv coordinates
	* at the corners of the images. Really simple.
	*/ 
	public void AssignPlaneMesh(ref Mesh msh) {
		// get the outline texture
		string path = AssetDatabase.GetAssetPath(mcd.outlineTexture);
		TextureImporter textureImporter = AssetImporter.GetAtPath(path) as TextureImporter;
		textureImporter.isReadable = true;
		AssetDatabase.ImportAsset(path);
			
		//Color[] pixels = mcd.outlineTexture.GetPixels();	// get the pixels to build the mesh from
			
		// do some size checking
		int imageHeight = mcd.outlineTexture.height;
		int imageWidth = mcd.outlineTexture.width;
		
		if ( ((float)imageWidth)/((float)imageHeight) != mcd.meshWidth/mcd.meshHeight) {
			Debug.LogWarning("Mesh Creator Inspector Warning: selected meshWidth and meshHeight is not the same proportion as source image width and height. Results may be distorted.");
			Debug.LogWarning("    You may want to resize your image to be square, it can be easier that way.");
		}
		
		// need a list of ordered 2d points
		Vector2 [] vertices2D = {new Vector2(0.0f,0.0f), new Vector2(0.0f, imageHeight), new Vector2(imageWidth, imageHeight), new Vector2(imageWidth,0.0f)};
        
		// 
		int[] indices = {0,1,2,0,2,3}; // these will be reversed for the back side
		Vector2[] frontUVs = {new Vector2(0.0f,0.0f), new Vector2(0.0f,1.0f), new Vector2(1.0f,1.0f), new Vector2(1.0f,0.0f) };
		Vector2[] uvs = new Vector2[vertices2D.Length];
		// Create the Vector3 vertices
		Vector3[] vertices = new Vector3[vertices2D.Length];
		
		float halfDepth = -mcd.meshDepth/2.0f;
		for (int i=0; i<vertices2D.Length; i++) {
			float vertX = 1.0f - (vertices2D[i].x/imageWidth) ; // get X point and normalize
			float vertY = vertices2D[i].y/imageHeight; // get Y point and normalize
			vertX = (vertX * mcd.meshWidth) - (mcd.meshWidth / 2.0f);  // scale X and position centered
			vertY = (vertY * mcd.meshHeight) - (mcd.meshHeight / 2.0f);
			vertX = vertX + mcd.widthOffset;
			vertY = vertY + mcd.heightOffset;
			vertices[i] = new Vector3(vertX -mcd.pivotWidthOffset, vertY - mcd.pivotHeightOffset, -halfDepth + mcd.depthOffset - mcd.pivotDepthOffset );
			uvs[i] = frontUVs[i];
		}
		
		msh.vertices = vertices;
		msh.triangles = indices;
		msh.uv = uvs;
		msh.RecalculateNormals();
		msh.RecalculateBounds();
		msh.name = mcd.outlineTexture.name + ".mesh";
		
		// this will get the pivot drawing in the correct place
		Bounds oldBounds = msh.bounds;
		msh.bounds = new Bounds(Vector3.zero, new Vector3(oldBounds.size.x, oldBounds.size.y, oldBounds.size.z));
	}
	
	/*
	*	AssignPlaneMesh() does calculation for a simple plane with uv coordinates
	* at the corners of the images. Really simple.
	*/ 
	public void AssignPlaneMeshBackside(ref Mesh msh) {
		// get the outline texture
		string path = AssetDatabase.GetAssetPath(mcd.outlineTexture);
		TextureImporter textureImporter = AssetImporter.GetAtPath(path) as TextureImporter;
		textureImporter.isReadable = true;
		AssetDatabase.ImportAsset(path);
						
		// do some size checking
		int imageHeight = mcd.outlineTexture.height;
		int imageWidth = mcd.outlineTexture.width;
		
		if ( ((float)imageWidth)/((float)imageHeight) != mcd.meshWidth/mcd.meshHeight) {
			Debug.LogWarning("Mesh Creator Inspector Warning: selected meshWidth and meshHeight is not the same proportion as source image width and height. Results may be distorted.");
			Debug.LogWarning("    You may want to resize your image to be square, it can be easier that way.");
		}
		
		// need a list of ordered 2d points
		Vector2 [] vertices2D = {new Vector2(0.0f,0.0f), new Vector2(0.0f, imageHeight), new Vector2(imageWidth, imageHeight), new Vector2(imageWidth,0.0f)};
        
		// 
		int[] indices = {2,1,0,3,2,0}; // these will be reversed for the back side
		Vector2[] frontUVs = {new Vector2(0.0f,0.0f), new Vector2(0.0f,1.0f), new Vector2(1.0f,1.0f), new Vector2(1.0f,0.0f) };
		Vector2[] uvs = new Vector2[vertices2D.Length];
		// Create the Vector3 vertices
		Vector3[] vertices = new Vector3[vertices2D.Length];
		
		float halfDepth = mcd.meshDepth/2.0f;
		for (int i=0; i<vertices2D.Length; i++) {
			float vertX = 1.0f - (vertices2D[i].x/imageWidth) ; // get X point and normalize
			float vertY = vertices2D[i].y/imageHeight; // get Y point and normalize
			vertX = (vertX * mcd.meshWidth) - (mcd.meshWidth / 2.0f);  // scale X and position centered
			vertY = (vertY * mcd.meshHeight) - (mcd.meshHeight / 2.0f);
			vertX = vertX + mcd.widthOffset;
			vertY = vertY + mcd.heightOffset;
			vertices[i] = new Vector3(vertX - mcd.pivotWidthOffset, vertY - mcd.pivotHeightOffset, -halfDepth + mcd.depthOffset - mcd.pivotDepthOffset);
			uvs[i] = frontUVs[i];
		}
			
		msh.vertices = vertices;
		msh.triangles = indices;
		msh.uv = uvs;
		msh.RecalculateNormals();
		msh.RecalculateBounds();
		msh.name = mcd.outlineTexture.name + ".mesh";
		
		// this will get the pivot drawing in the correct place
		Bounds oldBounds = msh.bounds;
		msh.bounds = new Bounds(Vector3.zero, new Vector3(oldBounds.size.x, oldBounds.size.y, oldBounds.size.z));
	}
	
	/*
	*	AssignEdgeMesh() does calculation of a uv mapped edge mesh from the raster image.
	*	no front or back planes are included
	*/ 
	public void AssignEdgeMesh(ref Mesh msh) {
			string path = AssetDatabase.GetAssetPath(mcd.outlineTexture);
			TextureImporter textureImporter = AssetImporter.GetAtPath(path) as TextureImporter;
			textureImporter.isReadable = true;
			AssetDatabase.ImportAsset(path);
			
			Color[] pixels = mcd.outlineTexture.GetPixels();	// get the pixels to build the mesh from
			
			// possibly do some size checking
			int imageHeight = mcd.outlineTexture.height;
			int imageWidth = mcd.outlineTexture.width;
			if ( ((float)imageWidth)/((float)imageHeight) != mcd.meshWidth/mcd.meshHeight) {
				Debug.LogWarning("Mesh Creator Inspector Warning: selected meshWidth and meshHeight is not the same proportion as source image width and height. Results may be distorted.");
				Debug.LogWarning("    You may want to resize your image to be square, it can be easier that way.");
			}
			
			// make a surface object to create and store data from image
			MC_SimpleSurfaceEdge mcs = new MC_SimpleSurfaceEdge(pixels,  imageWidth, imageHeight);
			
			if (!mcs.ContainsIslands()) {
				// need a list of ordered 2d points
				Vector2 [] vertices2D = mcs.GetOutsideEdgeVertices();
        
				// Use the triangulator to get indices for creating triangles
				//Triangulator tr = new Triangulator(vertices2D);
				//int[] indices = tr.Triangulate(); // these will be reversed for the back side
				Vector2[] uvs = new Vector2[vertices2D.Length * 2];
				// Create the Vector3 vertices
				Vector3[] vertices = new Vector3[vertices2D.Length * 2];
				//Vector3[] verticesBack = new Vector3[vertices2D.Length];
			
				float halfDepth = -mcd.meshDepth/2.0f;
				float halfVerticalPixel = 0.5f/imageHeight;
				float halfHorizontalPixel = 0.5f/imageWidth;
				for (int i=0; i<vertices2D.Length; i++) {
					float vertX = 1.0f - (vertices2D[i].x/imageWidth) - halfHorizontalPixel; // get X point and normalize
					float vertY = vertices2D[i].y/imageHeight + halfVerticalPixel; // get Y point and normalize
					vertX = (vertX * mcd.meshWidth) - (mcd.meshWidth / 2.0f);  // scale X and position centered
					vertY = (vertY * mcd.meshHeight) - (mcd.meshHeight / 2.0f);
					vertX = vertX + mcd.widthOffset;
					vertY = vertY + mcd.heightOffset;
					vertices[i] = new Vector3(vertX - mcd.pivotWidthOffset, vertY - mcd.pivotHeightOffset, -halfDepth + mcd.depthOffset - mcd.pivotDepthOffset); // vertex for side
					vertices[i +vertices2D.Length] = new Vector3(vertX - mcd.pivotWidthOffset, vertY - mcd.pivotHeightOffset, halfDepth + mcd.depthOffset - mcd.pivotDepthOffset);
					uvs[i] = mcs.GetUVForIndex(i);
					uvs[i+vertices2D.Length] = uvs[i];
				}
			
				// make the back side triangle indices
				// double the indices for front and back, 6 times the number of edges on front
				int[] allIndices = new int[vertices2D.Length  * 6];
			
				// create the side triangle indices
				// for each edge, create a new set of two triangles
				// edges are just two points from the original set
				for (int i = 0; i < vertices2D.Length - 1; i++) {
					allIndices[ (6 * i)] = i + 1;
					allIndices[ (6 * i) + 1] =  i ;
					allIndices[ (6 * i) + 2] =   i + 1 + vertices2D.Length;
					allIndices[ (6 * i) + 3] =   i + 1 + vertices2D.Length;
					allIndices[ (6 * i) + 4] =  i ;
					allIndices[ (6 * i) + 5] = i + vertices2D.Length;
				}
			
				// wrap around for the last face
				allIndices[allIndices.Length-6] = 0;
				allIndices[allIndices.Length-5] = vertices2D.Length-1;
				allIndices[allIndices.Length-4] =vertices2D.Length;
				allIndices[allIndices.Length-3] = vertices2D.Length;
				allIndices[allIndices.Length-2] = vertices2D.Length-1;
				allIndices[allIndices.Length-1] = (vertices2D.Length*2) - 1;
		
			
				msh.vertices = vertices;
				msh.triangles = allIndices;
				msh.uv = uvs;
				msh.RecalculateNormals();
				msh.RecalculateBounds();
				msh.name = mcd.outlineTexture.name + ".mesh";
				
				// this will get the pivot drawing in the correct place
				Bounds oldBounds = msh.bounds;
				msh.bounds = new Bounds(Vector3.zero, new Vector3(oldBounds.size.x, oldBounds.size.y, oldBounds.size.z));
			}
			else { // there be islands here, so treat mesh creation slightly differently
				ArrayList allVertexLoops = mcs.GetAllEdgeVertices();
				
				ArrayList completeVertices = new ArrayList();
				ArrayList completeIndices = new ArrayList();
				ArrayList completeUVs = new ArrayList();
				int verticesOffset = 0;
				int indicesOffset = 0;
				int uvOffset = 0;
				int loopCount = 0;
				foreach (Vector2[] vertices2D in allVertexLoops) {
					Vector2[] uvs = new Vector2[vertices2D.Length * 4];
					// Create the Vector3 vertices
					Vector3[] vertices = new Vector3[vertices2D.Length * 4];
			
					float halfDepth = -mcd.meshDepth/2.0f;
					float halfVerticalPixel = 0.5f/imageHeight;
					float halfHorizontalPixel = 0.5f/imageWidth;
					for (int i=0; i<vertices2D.Length; i++) {
						float vertX = 1.0f - (vertices2D[i].x/imageWidth) - halfHorizontalPixel; // get X point and normalize
						float vertY = vertices2D[i].y/imageHeight + halfVerticalPixel; // get Y point and normalize
						vertX = (vertX * mcd.meshWidth) - (mcd.meshWidth / 2.0f);  // scale X and position centered
						vertY = (vertY * mcd.meshHeight) - (mcd.meshHeight / 2.0f);
						vertX = vertX + mcd.widthOffset;
						vertY = vertY + mcd.heightOffset;
						vertices[i] = new Vector3(vertX - mcd.pivotWidthOffset, vertY - mcd.pivotHeightOffset, -halfDepth + mcd.depthOffset - mcd.pivotDepthOffset);
						vertices[i + vertices2D.Length] = new Vector3(vertX - mcd.pivotWidthOffset, vertY - mcd.pivotHeightOffset, halfDepth + mcd.depthOffset - mcd.pivotDepthOffset);
						uvs[i] = mcs.GetUVForIndex(loopCount, i);
						uvs[i+vertices2D.Length] = uvs[i];
					}
			
					// make the back side triangle indices
					// double the indices for front and back, 6 times the number of edges on front
					int[] allIndices = new int[vertices2D.Length * 6];
			
					// create the side triangle indices
					// for each edge, create a new set of two triangles
					// edges are just two points from the original set
					for (int i = 0; i < vertices2D.Length - 1; i++) {
						allIndices[(6 * i)] = i + 1 + verticesOffset;
						allIndices[(6 * i) + 1] = i + verticesOffset;
						allIndices[(6 * i) + 2] =  i + 1 + vertices2D.Length+ verticesOffset;
						allIndices[ (6 * i) + 3] =  i + 1 + vertices2D.Length+ verticesOffset;
						allIndices[(6 * i) + 4] =  i + verticesOffset;
						allIndices[(6 * i) + 5] =  i + vertices2D.Length+ verticesOffset;
					}
			
					// wrap around for the last face
					allIndices[allIndices.Length-6] =  0+ verticesOffset;
					allIndices[allIndices.Length-5] =vertices2D.Length-1+ verticesOffset;
					allIndices[allIndices.Length-4] = vertices2D.Length+ verticesOffset;
					allIndices[allIndices.Length-3] = vertices2D.Length+ verticesOffset;
					allIndices[allIndices.Length-2] = vertices2D.Length-1+ verticesOffset;
					allIndices[allIndices.Length-1] = (vertices2D.Length*2) - 1+ verticesOffset;
					
					foreach(Vector3 v in vertices) {
						completeVertices.Add(v);
					}
					foreach(Vector2 v in uvs) {
						completeUVs.Add(v);
					}
					foreach(int i in allIndices) {
						completeIndices.Add(i);
					}
					
					verticesOffset += vertices.Length;
					uvOffset += uvs.Length;
					indicesOffset += allIndices.Length;
					loopCount++;
				}
				msh.vertices = (Vector3[]) completeVertices.ToArray(typeof(Vector3));
				msh.triangles = (int[]) completeIndices.ToArray(typeof(int));
				msh.uv = (Vector2[]) completeUVs.ToArray(typeof(Vector2));
				msh.RecalculateNormals();
				msh.RecalculateBounds();
				msh.name = mcd.outlineTexture.name + ".mesh";
				
				// this will get the pivot drawing in the correct place
				Bounds oldBounds = msh.bounds;
				msh.bounds = new Bounds(Vector3.zero, new Vector3(oldBounds.size.x, oldBounds.size.y, oldBounds.size.z));
			}
	}
}

